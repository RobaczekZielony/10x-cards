# API Endpoint Implementation Plan: POST /generations

## 1. Endpoint Overview
- This endpoint initiates an AI-powered flashcard suggestion generation process.
- It validates that the input text (`source_text`) is between 1000 and 10000 characters.
- Upon successful validation, it calls an external LLM API (via Openrouter.ai) to generate flashcard suggestions.
- Generation metadata, including flashcards count, duration, and suggestions, is stored in the `generations` table.
- In case of errors (e.g., API failure or input validation), error logs are recorded in the `generation_error_logs` table.

## 2. Request Details
- **HTTP Method:** POST
- **URL Pattern:** /generations
- **Headers:** Authorization header must be provided for user authentication.
- **Request Body:** JSON payload containing:
  - **source_text** (string): The text input for generating flashcards. Must be between 1000 and 10000 characters.

## 3. Utilized Types
- **Request DTO:** `CreateGenerationRequestDto` (defined in @types.ts) which includes `source_text`.
- **Response DTO:** `CreateGenerationResponseDto` (defined in @types.ts) which includes:
  - `id` (uuid)
  - `user_id` (uuid)
  - `model` (string)
  - `duration` (number)
  - `flashcards_count` (number)
  - `flashcard_suggestions` (GenerationSuggestionDto[]): Refers to an array of flashcard suggestion DTOs 

## 4. Response Details
- **Success (201 Created):** Returns a JSON response containing generation metadata and the flashcard suggestions generated by the LLM. The response structure is as follows:
  ```json
  {
    "id": "<generated id>",
    "flashcards_count": <number>,
    "flashcard_suggestions": [
      {
        "front_text": "...",
        "back_text": "...",
        "source": "..."
      }
      // ... additional suggestions
    ]
  }
  ```
- **Error Responses:**
  - **400 Bad Request:** When input text does not meet the length requirements.
  - **401 Unauthorized:** When the requester is not authenticated.
  - **500 Internal Server Error:** For unexpected errors such as external API failures.

## 5. Data Flow
1. **Input Validation:** Validate the `source_text` length immediately upon receiving the request (using `zod` library).
2. **Authentication:** Use Supabase authentication middleware (or context.locals.supabase) to verify the user.
3. **Service Call:** On valid input, initiate a call to the `generation.service` which: 
 - Calls external LLM API via Openrouter.ai, passing the `source_text`.
 - Insert a new record in the `generations` table with key metadata (user_id, model, duration, flashcards_count, source_text).
 - If flashcard suggestions are received, include them in the response payload.
4. **Error Logging:** If any errors occur (e.g., external API failure, parsing issues), record details in the `generation_error_logs` table.
5. **Response:** Responses to the client with the data according to `CreateGenerationResponseDto`

## 6. Security Considerations
- **Authentication:** Ensure only authenticated users can access this endpoint via Supabase Auth integration.
- **Input Validation:** Strictly enforce `source_text` length constraints (using `zod` library) to prevent abuse and reduce load on the external API.
- **Data Sanitization:** Sanitize all inputs to prevent injection attacks before using them in any queries or external API calls.

## 7. Error Handling
- **400 Bad Request:** Return meaningful messages when `source_text` length validation fails.
- **401 Unauthorized:** Return a 401 status if user authentication fails.
- **500 Internal Server Error:** Catch and log unexpected exceptions, especially failures from the external LLM API call.
- Error details should be logged in the `generation_error_logs` table with appropriate error codes and messages.

## 8. Performance Considerations
- **Asynchronous External Calls:** Ensure that the call to the external API is handled asynchronously to avoid blocking the server response.
- **Efficient DB Operations:** Use batched or transactional operations where possible when inserting generation records and error logs.
- **Caching:** Consider caching frequently requested model metadata if applicable to reduce repeated external calls.
- **Timeout Handling for External LLM Call:** Implement a configurable timeout (60 seconds by default) for the external LLM call to prevent blocking the application. If the external service does not respond within the defined timeframe, abort the request gracefully to maintain responsiveness.
- **Monitoring:** monitoring performance of external LLM calls and endpoint performance

## 9. Implementation Steps
1. **Create file:** Create endpoint file `src/pages/api`, e.g. `generations.ts`
2. **Authentication:** Integrate with Supabase Auth using `context.locals.supabase`.
3. **Input Validation:** Implement a check to ensure that `source_text` is between 1000 and 10000 characters (using `zod` library).
4. **Create service:** Create service `generation.service`, which:
  - Integrates with an external LLM (using OpenRouter), in the development phase use mock instead of calling real LLM
  - Write logic to insert a new record in the `generations` table. Use returning queries to fetch the newly created generation record.
  - Implement error handling that writes to the `generation_error_logs` table in case of failures.
5. **Response Construction:** Construct the response payload using the `CreateGenerationResponseDto` type and return a 201 status code on success.
6. **Documentation:** Update API documentation to reflect the new endpoint and its usage, parameters, and potential responses. 