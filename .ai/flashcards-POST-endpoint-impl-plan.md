# API Endpoint Implementation Plan: POST /flashcards

## 1. Endpoint Overview
This endpoint is designed to create multiple flashcards in a single API request. It accepts an array of flashcard objects with required fields for text and source, and an optional field to reference an AI generation. The endpoint validates incoming data, inserts flashcards into the database under the authenticated user's account, and returns the created flashcards along with a summary of the operation.

## 2. Request Details
- **HTTP Method:** POST
- **URL Pattern:** /flashcards
- **Parameters:** None in the URL
- **Request Body:** JSON object containing a single key `flashcards` which is an array of objects. Each object must include:
  - **Required:**
    - `front_text` (string; max 200 characters)
    - `back_text` (string; max 500 characters)
    - `source` (enum, e.g., "manual", "ai-full", "ai-edited")
  - **Optional:**
    - `generation_id` (UUID, used if the flashcard is generated by AI)
- **Authentication:** The endpoint requires a valid user session. Authentication is verified using Supabase Auth via `context.locals`.

## 3. Utilized Types
- **Request DTOs:**
  - `CreateFlashcardsRequestDto` – defines the structure for the flashcards creation request.
  - `CreateFlashcardDto` – defines the structure for each individual flashcard in the request.
- **Response DTOs:**
  - `FlashcardDto` – represents the flashcard data returned to the client (includes `id`, `created_at`, and `updated_at` among other fields).
  - `CreateFlashcardsResponseDto` – wraps the array of flashcards along with `success_count` and `error_count`.

## 4. Response Details
- **Success (201 Created):** Returns a JSON object containing:
  - `flashcards`: Array of created flashcard objects with fields `id`, `front_text`, `back_text`, `source`, `generation_id` (if applicable), `created_at`, and `updated_at`.
  - `success_count`: Number of flashcards successfully created.
  - `error_count`: 0 (or the number of flashcards that failed if partial failures are handled).
- **Error Responses:**
  - **400 Bad Request:** When input validation fails.
  - **401 Unauthorized:** When the request is made by an unauthenticated user.
  - **500 Internal Server Error:** For any unexpected errors during processing.

## 5. Data Flow
1. **Incoming Request:** The client sends a POST request with the JSON payload containing the flashcards array.
2. **Authentication:** The API verifies the user using the Supabase authentication mechanism via `context.locals`.
3. **Validation:** The request payload is validated using Zod schemas constructed around the `CreateFlashcardsRequestDto` model.
4. **Service Layer:** Validated data is passed to a dedicated service function (e.g., `flashcardsService.createFlashcards()`) responsible for the database insertion.
5. **Database Interaction:** The service uses the Supabase client to insert the flashcards in a batch operation, handling transactions to ensure atomicity.
6. **Response Formation:** The inserted flashcard records (with auto-generated fields like `id`, `created_at`, `updated_at`) are formatted into the response payload.
7. **Outgoing Response:** The endpoint returns a 201 Created response with the results or appropriate error messages.

## 6. Security Considerations
- **Authentication & Authorization:** Ensure only authenticated users can invoke this endpoint and that the flashcards are associated with the correct user.
- **Input Validation:** Comprehensive data validation using Zod schemas to enforce structure, limits, and accepted enum values.

## 7. Error Handling
- **Validation Errors (400):** Triggered when input data fails schema validation.
- **Authentication Errors (401):** If the user is not authenticated or session has expired.
- **Database Operation Failures (500):** Catch and log database transaction errors or unexpected exceptions.
- **Edge Cases:** Decide if partial insertions are allowed or if the request should rollback entirely in the event of an error; log detailed error messages for debugging and operational monitoring.

## 8. Performance Considerations
- **Batch Inserts:** Utilize bulk insertion to reduce the number of database round trips.
- **Transaction Management:** Use database transactions to ensure atomicity and consistency during batch operations.
- **Payload Size Check:** Enforce limits on the number of flashcards that can be created in one request to protect server resources.
- **Efficient Validation:** Optimize Zod schema validation to reduce overhead on large payloads.

## 9. Implementation Steps
1. **Create/Update API Route:**
   - Define an Astro API route at `/src/pages/api/flashcards.ts` to handle the POST method.
2. **Define Validation Schema:**
   - Use Zod to create a schema that validates the structure of `CreateFlashcardsRequestDto` and each `CreateFlashcardDto`.
3. **Implement Service Function:**
   - Create or update a service in `src/lib/services/flashcards.service.ts` with a function like `createFlashcards()` to perform the database insertion.
   - Ensure the service uses transaction management for batch insertion.
4. **Authentication Check:**
   - In the API route, extract and verify the authenticated user from `context.locals`.
5. **Payload Validation:**
   - Validate the incoming request payload against the Zod schema.
   - Return a 400 response if the validation fails.
6. **Database Insertion:**
   - Call the service function to insert flashcards into the database.
   - Handle generation of IDs, timestamps, and association with the user.
7. **Error Logging & Handling:**
   - Log errors using an appropriate logging mechanism.
   - Return 500 if an internal error occurs or 401 if authentication fails.
8. **Send Response:**
   - Construct the response using the `CreateFlashcardsResponseDto` structure.
   - Respond with 201 Created alongside the created flashcards, `success_count`, and `error_count`.
